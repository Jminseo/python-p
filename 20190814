C:\Users\전민서\PycharmProjects\untitled\venv\Scripts\python.exe "C:\Program Files\JetBrains\PyCharm 2019.2\helpers\pydev\pydevconsole.py" --mode=client --port=7828
import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\전민서\\PycharmProjects\\untitled', 'C:/Users/전민서/PycharmProjects/untitled'])
PyDev console: starting.
Python 3.7.4 (tags/v3.7.4:e09359112e, Jul  8 2019, 19:29:22) [MSC v.1916 32 bit (Intel)] on win32
seconds_per_day = seconds_per_hour * 24
Traceback (most recent call last):
  File "<input>", line 1, in <module>
NameError: name 'seconds_per_hour' is not defined
seconds_per_hour = 60 * 60
seconds_per_day = seconds_per_hour * 24
seconds_per_day
86400
# 2.6 seconds_per_day를 seconds_per_hours로 나누어 정수만 구하세요
import this
The Zen of Python, by Tim Peters
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
seconds_per_day//seconds_per_hour
24
coffee = 4100
juice = 4600
tea = 3900
# 3 coffee, 2 juice, 1 tea
# 3 coffee, 4 juice, 3 tea
3 * "coffee" + 2 * "juice" + 1 * "tea"
'coffeecoffeecoffeejuicejuicetea'
3 * coffee + 2 * juice + tea
25400
3 * coffee + 4 * juice + 3 * tea
42400
# 출생년도에 대한 리스트 year_list를 만드세요
# 출생년도를 첫 번째 요소로 하고 1년씩 증가하는 
# 리스트의 다섯 번째 생일까지의 요소를 넣으세요
# 출생년도가 1980이라고 가정하세요
year_list = [1980, 1981, 1982, 1983, 1984, 1985]
# year_list의 세 번째 생일의 년도를 구하세요
year_list[3]
1983
# year_list 중 가장 나이가 많을 때의 년도를 -를 사용하여 구하세요
year_list[-1]
1985
# 리스트를 만드세요
# 리스튼 "God", "Jesus", "Holy" 세 문자열을 요소로 만드세요
things = ["God", "Jesus", "Holy"]
things
['God', 'Jesus', 'Holy']
things2 = ["God", "Jesus", "Holy", "sin"]
things2
['God', 'Jesus', 'Holy', 'sin']
# things 리스트의 처음 요소를 모두 대문자로 변경하여 출력하세요
# things 리스트의 두 번째 요소를 모두 소문자로 변경하여 출력하세요
# things 리스트의 세 번째 요소를 첫 글자만 대문자로 변경하여 출력하세요
things.upper()
Traceback (most recent call last):
  File "<input>", line 1, in <module>
AttributeError: 'list' object has no attribute 'upper'
things2.upper()
Traceback (most recent call last):
  File "<input>", line 1, in <module>
AttributeError: 'list' object has no attribute 'upper'
things2 = ["God", "Jesus", "Holy", "sin"]
things[0].upper()
'GOD'
things2[1].lower()
'jesus'
things[2].capitalize()
'Holy'
# things 리스트의 처음 요소를 모두 대문자로 변경하여 저장하세요
things[0] = things[0].upper()
things2[0] = things[0].upper()
things2
['GOD', 'Jesus', 'Holy', 'sin']
del(things2[-1])
things2
['GOD', 'Jesus', 'Holy']
# surprise 리스트를 생성하세요
# 이 리스트는 "Belief", "Hope" , "Love" 세 문자열을 요소로 만드세요
surprise = [Belief, Hope, Love]
Traceback (most recent call last):
  File "<input>", line 1, in <module>
NameError: name 'Belief' is not defined
surprise = ["Belief", "Hope", "Love"]
# surprise 리스트의 마지막 요소를 소문자로 변경하고 첫 글자만 대문자로 변경 저장하세요
surprise[-1] = surprise[-1].lower()
surprise[-1] = surprise[-1].capitalize()
surprise
['Belief', 'Hope', 'Love']
# 영어-프랑스어 사전을 의미하는 e2f 딕셔너리를 만드세요
# 영어의 dog는 프랑스어 chien이고 cat은 chat, walrus는 morse로 구성하세요
e2f = {"dog" : "chien", "cat" : "chat", "walrus" : "morse"}
e2f
{'dog': 'chien', 'cat': 'chat', 'walrus': 'morse'}
# e2f 딕셔너리에서 영어 walrus를 프랑스어로 출력하세요
e2f["walrus"]
'morse'
# e2f 딕셔너리에서 영어 cross를 프랑스어 croix로 추가하세요
# e2f 딕셔너리에서 첫 번째 요소를 삭제하세요
remove
Traceback (most recent call last):
  File "<input>", line 1, in <module>
NameError: name 'remove' is not defined
e2f["cross" : "croix"]
Traceback (most recent call last):
  File "<input>", line 1, in <module>
TypeError: unhashable type: 'slice'
# e2f 딕셔너리의 영어 단어 키를 출력하세요
e2f.keys()
dict_keys(['dog', 'cat', 'walrus'])
list(e2f.keys())
['dog', 'cat', 'walrus']
prices = []
temps = [32.0, 212.0, 0.0, 81.6, 100.0, 45.3]
words = ["hello", "world"]
car_details = ["Toyota", "RAV4" , "2.2", "60807"]
everything = [prices, temps, words, car_details]
vowels = ["a", "e", "i", "o", "u"]
word = "Milliways"
found = []
len(found)
0
found.append("a")
len(found)
1
found
['a']
found.append("e")
found.append("i")
found.append("o")
len(found)
4
found
['a', 'e', 'i', 'o']
if "u" not in found:
    found.append("u")
    
nums = [1, 2, 3, 4]
nums.pop()
4
nums
[1, 2, 3]
nums.pop()
3
nums
[1, 2]
nums.extend([3, 4])
nums
[1, 2, 3, 4]
nums.extend()
Traceback (most recent call last):
  File "<input>", line 1, in <module>
TypeError: extend() takes exactly one argument (0 given)
nums.extend([])
nums
[1, 2, 3, 4]
nums.insert(0, 1)
nums
[1, 1, 2, 3, 4]
nums.insert(2, "two-and-a-half")
nums
[1, 1, 'two-and-a-half', 2, 3, 4]
person3 = { "name": "Ford Prefect",}
person3 = { "name": "Ford Prefect", "Gender": "Male", "Occupation": "Researcher", "Home Planet": "Betelgeuse Seven"}
person3
{'name': 'Ford Prefect', 'Gender': 'Male', 'Occupation': 'Researcher', 'Home Planet': 'Betelgeuse Seven'}
found = {}
found
{}
found["a"] = 0
found["e"] = 0
found["i"] = 0
found["o"] = 0
found["u"] = 0
found
{'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}
found["e"] = found["e"] + 1
found
{'a': 0, 'e': 1, 'i': 0, 'o': 0, 'u': 0}
found["e"] += 1
found
{'a': 0, 'e': 2, 'i': 0, 'o': 0, 'u': 0}
